# Thread의 개념과 활용

## 1. 서론

게임을 하거나, 또는 프로그래밍을 하다 보면 '멀티 스레드', '멀티 코어'라는 용어를 접할 수 있다. 멀티 코어란 무엇이고, 멀티 스레드란 무엇을 말하는 것일까? 그리고 멀티 스레드와 멀티 코어는 무엇이기에 이것을 적용한 게임들의 퍼포먼스가 싱글 코어 게임보다 더 좋다고 하는 것일까? 그리고 멀티 스레드에서 복수로 존재하는 스레드는 무엇일까? 본 글에서는 멀티 코어와 멀티 스레드, 그리고 스레드에 대한 개념을 다룬다.

## 2. 스레드(thread)

### 2.1. 스레드의 개념

스레드는 하나의 PC(Program Counter)와 같다고 볼 수 있다. 좀 더 쉽게 말하자면, 스레드는 프로그램 내부의 흐름의 단위를 의미하며, 일반적으로 하나의 프로그램은 하나의 스레드를 갖는다.[^1][^2] 

### 2.2. 멀티 스레드의 개념과 장점

멀티 스레드는 프로그램 환경에 따라 둘 이상의 스레드가 동시에 실행되는 방식을 의미한다.[^2] 즉, 하나의 프로그램 내부에서 독립적으로 코드의 실행이 이루어지는 부분이 둘 이상이면 멀티 스레드 프로그램이라고 볼 수 있다. 한 프로그램 내부에서 둘 이상의 실행 흐름이 필요한 경우는 대표적으로 타이머가 있을 수 있다. 특정 시간이 지나면 프로그램이 종료되는 경우를 생각해보자. 만약에 단일 스레드만으로 이런 프로그램을 처리하려고 하면 대부분의 경우는 타이머가 끝날 때까지 해당 프로세스에서 다른 작업을 할 수 없거나, 1초마다 뚝뚝 끊기는 것 처럼 보일 것이다.  다중 스레드를 사용할 수 있다면 이는 간단한 문제로 바뀐다. 타이머의 시간을 재고, 프로그램을 종료시키는 흐름과 프로그램의 다른 기능의 흐름을 분리시키는 것이다. 이렇게 하면 한 프로그램 내에서 간단하게 시간이 지나면 종료되는 프로그램을 구현할 수 있다.

만약에 CPU가 여러개(멀티코어)라면, 이 독립된 프로그램의 흐름을 서로 다른 CPU에 배치하여 전체적인 응답 시간을 높일 수 있다. A라는 작업과 B라는 작업이 있다고 하자. 한 CPU 코어에서 A가 처리되는데 5초, B가 처리되는데 5초가 걸린다고 하면 A와 B를 한 CPU 코어에서 처리하는데는 10초라는 시간이 걸릴 것이다. 하지만 복수의 CPU 코어가 존재하고, A와 B 작업을 독립된 스레드로 나누어서 CPU 코어에 할당할 수 있다면 두 CPU 코어를 활용해서 전체 처리 시간을 5초로 단축시킬 수 있다.

정리하자면, 멀티코어는 하드웨어 상에서 CPU 코어가 여러 개 존재하는 형태를 말하고, 멀티 스레드는 프로그램의 실행 흐름의 단위가 2개 이상인 것을 말한다.

### 2.3. 스레드와 프로세스

윈도우즈 작업 관리자를 열어서 프로그램들을 보다보면 어떤 프로그램들은 2개 이상의 프로세스로 구성되는 것을 알 수 있다. 그렇다면 하나의 프로그램에 왜 여러개의 프로세스가 존재하는 것일까?

먼저 프로세스란 무엇인지에 대해서 알아야 한다. 아래는 위키백과 한국어판에서 프로세스를 정의한 것이다.

> "프로세스(process)는 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램을 말한다. 종종 스케줄링의 대상이 되는 작업(task)라는 용어와 거의 같은 의미로 쓰인다.[^3]"
>
> <span style="display:inline-block; width:100%; height:100%; text-align:right">*-한국어 위키백과 프로레스 문서-*</span>

프로그램과 프로세스의 이름이 유사한 탓에, 두 개를 헷갈릴수도 있다. 그러나 프로그램은 하드 디스크 등에 저장되어 있는 실행 코드들을 의미하고, 프로세스는 구동된 프로그램과 프로그램의 상태가 메모리 상에서 실행되는, 하나의 작업 단위를 의미한다.[^3]

그렇다면 이렇게 생각해볼 수 있다. '프로그램에서 실행 흐름의 분리가 필요한 코드를 프로세스로 만들어서, 즉, 두 개의 프로세스를 실행시켜서 처리할 수 있지 않을까?' 이런 의문을 구현한 것이 멀티 프로세스이다. 멀티 프로세스는 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.[^4]멀티 프로세스의 장점은 여러개로 분할된 자식 프로세스들 중, 하나에 문제가 발생하더라도 그 자식 프로세스가 죽는 것으로 끝난다는 것이다. 부모 프로세스가 죽는다던지 하는 다른 영향이 확산되지 않는다.

그러나 멀티 프로세스에는 단점들이 존재한다. Context Switching에서의 오버헤드가 그것이다. Context Switching이란 CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는 과정을 의미한다. 구체적으로는 동작중인 프로세스가 대기하면 해당 프로세스의 상태(Context)를 저장하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.[^4] Context Switching 과정에서는 캐쉬 메모리 초기화 등 무거운 작업이 진행되고 많은 시간이 소요된다. 또다른 단점은 각 프로세스마다 독립된 메모리 영역을 부여받았기 때문에, 하나의 프로그램에 속하는 다른 프로세스들 사이에서 변수를 공유할 수 없다. 프로세스 사이에서 정보를 주고받기 위해서는 IPC를 사용해야만 한다.

그렇다면 멀티 스레드 프로그램은 어떨까. 멀티 스레드 프로그램은 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있고, 스레드 간 데이터를 주고 받는 것이 간단하기 때문에 시스템 자원 소모가 줄어들며, Context Switching이 빠르다. 스레드는 프로세스 내의 Stack 영역을 제외한 모든 메모리를 공유하기 떄문에 다른 스레드의 변수에 쉽게 접근할 수 있다.[^4]

### 2.4. 멀티 스레드의 단점

2.2절과 2.3절에서는 멀티 스레드의 장점들을 위주로 살펴보았다. 하지만 멀티 스레드에도 단점들이 존재한다.  멀티 스레드는 다음과 같은 단점들을 가진다.[^4]

1. 주의 깊은 설계의 필요
2. 디버깅이 까다로움
3. 단일 프로세스 시스템의 경우 효과를 기대하기 어려움
4. 다른 프로세스에서 스레드를 제어할 수 없음
5. 멀티 스레드의 경우 자원 공유의 문제가 발생(동기화 문제)
6. 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받음

1은 2, 5, 그리고 6과 연관되는 문제이다. 5의 경우가 특히 중요한데,  실질적으로 1, 2, 6은 5의 문제에서 파생되는 것이기 때문이다. 스레드간에 변수와 같은 자원을 공유하는 것은 장점이기도 하지만 동시에 프로그래머가 주의하지 않으면 문제가 발생할 수 있다.

```c++
#include <iostream>
#include <thread>

int i = 0;

void ThreadFunc()
{
    for( int c = 0; c < 10000000; c++ ) {
        int a = i;
        a++;
        i = a;
    }
}

int main( void )
{
    std::thread t1( ThreadFunc );
    std::thread t2( ThreadFunc );

    t1.join();
    t2.join();

    std::cout << i;

    return 0;
}
```

위 코드는 간단한 스레드의 사용예시이다. C++로 작성되었으며, 두 스레드에서 실행하는 함수는 동일하다. 단순히 지역변수 a에 전역변수 i의 값을 저장하고, a의 값을 증가시킨 다음에, i에 다시 a를 대입한다. 각 스레드에서 이 과정을 1000000번 수행하므로 기대하는 i의 값은 2000000이다.

```
11258751
```

그러나 실제로 수행시켜보면 기대한 값이 아닌 엉뚱한 값이 나온다. 이는 스레드의 실행순서, 다시 말하면 프로그램의 흐름의 순서가 각 스레드마다 다르기 때문이다.  그리고 우리는 어느 스레드가 먼저  실행되는지 그 순서를 알 수 없다. [^2] 예를 들어,  1번 스레드가 i를 1로 만들었지만, 2번 스레드가  i값이 0일 때를 기준으로 동작중이라서 a에 0을 할당한다. 그리고 2번 스레드는 a값을 1증가시킨 뒤 다시 i를 1로 만든다. 1번 스레드에서는 2번 스레드의 동작 후 a에 1을 대입한다. 기대하는 것은 2번 스레드가 a에 1을 넣는것이지만, 스레드간의 실행순서를 알 수 없기 때문에 기대한 값이 나오지 않는 것이다.

이를 방지하기 위해서 Mutex와 세마포어(Semaphore)와 같은 해결방안들이 제시되었으며, 멀티 스레드에서 발생하는 이 문제를 경쟁 상태(race condition)이라고 부른다.[^5]

------

## 참고문헌(Reference)

[^1]: dusto potato, "[OS] 스레드, 멀티코어와 멀티스레드", dust_potato.log, 2021-08-21, Accessed on: 2022-09-08 10:38:42
[^2]: "스레드 (컴퓨팅)", 위키백과 한국어판, Accessed on: 2022-09-08 10:47:40 
[^3]: "프로세스", 위키백과 한국어판, Accessed on: 2022-09-08 13:25:41
[^4]: heejeong Kwon, "[OS] 프로세스와 스레드의 차이", Heee's Development Blog, 2022-09-14, Accessed on: 2022-09-08 21:41:52-
[^5]: 머니덕, "C++ 기초 개념 15-2 : 뮤텍스(Mutex)와 조건 변수(Condition Variable)", KoreanFoodie's Study, 2022-04-19 10:23, Accessed on: 2022-09-08 23:03:13

